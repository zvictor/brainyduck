#!/usr/bin/env node

import fs from 'fs'
import path from 'path'
import _debug from 'debug'
import { parse } from 'graphql'
import { codegen } from '@graphql-codegen/core'
import { execaSync } from 'execa'
import { fileURLToPath } from 'url'
import * as typescriptPlugin from '@graphql-codegen/typescript'
import * as typescriptOperations from '@graphql-codegen/typescript-operations'
import * as typescriptGraphqlRequest from '@graphql-codegen/typescript-graphql-request'
import { temporaryFile, temporaryDirectory } from 'tempy'
import { findBin, pipeData, patternMatch, locateCache } from '../utils.js'
import push from './deploy-schemas.js'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

const debug = _debug('brainyduck:build')

const config = {
  filename: 'output.ts',
  plugins: [
    // Each plugin should be an object
    {
      typescript: {}, // Here you can pass configuration to the plugin
    },
    { ['typescript-operations']: {} },
    {
      ['typescript-graphql-request']: {},
    },
  ],
  pluginMap: {
    typescript: typescriptPlugin,
    ['typescript-operations']: typescriptOperations,
    ['typescript-graphql-request']: typescriptGraphqlRequest,
  },
}

const generateOperations = async (schema) => {
  debug(`generating operations documents`)
  const schemaFile = temporaryFile()
  let operationsDir = temporaryDirectory()

  fs.writeFileSync(schemaFile, schema)
  const { stdout, stderr, exitCode } = execaSync(
    findBin(`gqlg`),
    [`--schemaFilePath`, schemaFile, `--destDirPath`, `./output`],
    { cwd: operationsDir }
  )
  operationsDir = path.join(operationsDir, `./output`)

  if (exitCode) {
    console.error(stderr)
    throw new Error(`Brainyduck could not generate operations automatically`)
  }

  if (stderr) console.warn(stderr)
  if (stdout) debug(stdout)
  debug(`The operations documents have been auto generated at ${operationsDir}`)
  return operationsDir
}

const generateSdk = async (schema, documentsPattern) => {
  debug(`Looking for documents matching '${documentsPattern}'`)
  const autoGeneratedDocuments = process.env.BRAINYDUCK_NO_OPERATIONS_GENERATION
    ? []
    : await patternMatch(`**/*.gql`, await generateOperations(schema))
  debug(`${autoGeneratedDocuments.length} operations documents have been auto generated`)

  const documents = [
    ...autoGeneratedDocuments,
    ...(await patternMatch(
      Array.isArray(documentsPattern) ? documentsPattern : documentsPattern.split(',')
    )),
  ].map((x) => ({
    location: x,
    document: parse(fs.readFileSync(path.resolve(x), 'utf8')),
  }))

  return await codegen({
    ...config,
    documents,
    schema: parse(schema),
  })
}

export default async function main(
  schemaPattern,
  documentsPattern = '**/[a-z]*.(graphql|gql)',
  { cache, output } = { cache: true }
) {
  debug(`called with:`, { schemaPattern, documentsPattern, cache, output })

  if (cache) {
    if (output) throw new Error(`Options 'cache' and 'output' are mutually exclusive`)

    output = locateCache('sdk.ts')
    fs.rmSync(locateCache(), { force: true, recursive: true })
  }

  const schema = await push(await schemaPattern, { puke: true })

  debug(`Generating TypeScript SDK`)
  const sdk = `// Temporary workaround for issue microsoft/TypeScript#47663
// Solution found at https://github.com/microsoft/TypeScript/issues/47663#issuecomment-1270716220
import type {} from 'graphql';

${await generateSdk(schema, await documentsPattern)}

/**
 *
 *  💸 This schema was generated in the cloud at the expense of the Brainyduck maintainers  📉
 *
 *  😇            Please kindly consider giving back to the Brainyduck community            😇
 *
 *  🐥🙏             The DUCK needs your help to spread his word to the world!             🙏🐥
 *
 *                                  https://duck.brainy.sh
 *                            https://github.com/sponsors/zvictor
 *
 *  🌟💎🎆            [THIS SPACE IS AVAILABLE FOR ADVERTISING AND SPONSORSHIP]            🎆💎🌟
 *
 **/
export default function brainyduck({
  secret = process?.env.FAUNA_SECRET,
  endpoint = process?.env.FAUNA_ENDPOINT,
} = {}) {
  if (!secret) {
    throw new Error('SDK requires a secret to be defined.')
  }

  return getSdk(
    new GraphQLClient(endpoint || 'https://graphql.fauna.com/graphql', {
      headers: {
        authorization: secret && \`Bearer \${secret}\`,
      },
    })
  )
}

export { brainyduck }`

  if (!output) {
    return sdk
  }

  const outputDir = path.dirname(output)

  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true })
  }

  fs.writeFileSync(output, sdk)
  debug(`The sdk has been stored at ${output}`)

  if (!cache) {
    return output
  }

  const tsconfigFile =
    process.env.BRAINYDUCK_TSCONFIG || path.join(__dirname, '..', 'tsconfig.json')
  const tmpTsconfigFile = locateCache('tsconfig.json')

  debug(`Transpiling sdk with tsconfig at ${tsconfigFile}`)
  debug(`Caching files at ${locateCache()}`)

  if (!fs.existsSync(tsconfigFile)) {
    throw new Error(`The tsconfig file you specified does not exist.`)
  }

  if (!fs.existsSync(locateCache())) {
    fs.mkdirSync(locateCache(), { recursive: true })
  }

  fs.writeFileSync(
    tmpTsconfigFile,
    `{
      "extends": "${tsconfigFile}", "include": ["${output}"], "compilerOptions": {
        "outDir": "${locateCache()}",
        ${
          /*
          Fix for the error TS2742: `The inferred type of "X" cannot be named without a reference to "Y". This is likely not portable. A type annotation is necessary.`
          https://github.com/microsoft/TypeScript/issues/42873#issuecomment-1131425209
        */ ''
        }
        "baseUrl": "${path.join(__dirname, '..')}",
        "paths": { "*": ["node_modules/*/"]}
      }
    }`
  )

  const { stdout } = execaSync(
    findBin(`tsup`),
    [
      output,
      '--config',
      path.join(__dirname, '..', 'tsup.config.ts'),
      '--out-dir',
      locateCache(),
      '--tsconfig',
      tmpTsconfigFile,
    ],
    {
      stdio: ['ignore', 'pipe', process.stderr],
      cwd: path.join(__dirname, '..'),
    }
  )
  debug(stdout)

  debug(`The sdk has been transpiled and cached`)
  return output
}

if (process.argv[1] === fileURLToPath(import.meta.url)) {
  const [schemaPattern, documentsPattern, output] = process.argv.slice(2)

  ;(async () => {
    const location = await main(
      schemaPattern === '-' ? pipeData() : schemaPattern,
      documentsPattern === '-' ? pipeData() : documentsPattern,
      output && { output }
    )

    console.log(`The sdk has been saved at ${location}`)
    process.exit(0)
  })()
}
